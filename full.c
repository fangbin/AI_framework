/* Generated by Frama-C */
#include "errno.h"
#include "getopt.h"
#include "stdarg.h"
#include "stdio.h"
#include "unistd.h"
struct hdr {
   struct hdr *ptr ;
   unsigned int size ;
};
typedef struct hdr HEADER;
void laInit(void);

void laFree(void *ap);

void *laAlloc(int nbytes);

HEADER _heapstart = {.ptr = (struct hdr *)0, .size = (unsigned int)0};
HEADER _heapend = {.ptr = (struct hdr *)0, .size = (unsigned int)0};
/*@ requires /* ip:61 */valid_read_string{Here}(format);
    requires /* ip:60 */valid_read_string{Here}(param0);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            *(param0 + (0 ..));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            *(param0 + (0 ..));
 */
int printf_va_1(char const *format, char *param0);

void warm_boot(char *str)
{
  /* sid:1 */
  printf_va_1("%s\n",str);
  /* sid:97 */
  return;
}

HEADER *frhd;
static short memleft;
void laFree(void *ap)
{
  /* Locals: nxt, prev, f */
  HEADER *nxt;
  HEADER *prev;
  HEADER *f;
  /* sid:4 */
  f = (HEADER *)ap - 1;
  /* sid:5 */
  memleft = (short)((unsigned int)memleft + f->size);
  /* sid:7 */
  if (frhd > f) {
    /* sid:8 */
    nxt = frhd;
    /* sid:9 */
    frhd = f;
    /* sid:10 */
    prev = f + f->size;
    /* sid:12 */
    if (prev == nxt) {
      /* sid:13 */
      f->size += nxt->size;
      /* sid:14 */
      f->ptr = nxt->ptr;
    }
    else {
      /* sid:15 */
      f->ptr = nxt;
    }
    /* sid:99 */
    /*block:begin*/ { /* sid:100 */
                      goto return_label; } /*block:end*/
  }
  else {
    
  }
  /* sid:18 */
  prev = (HEADER *)0;
  /* sid:19 */
  nxt = frhd;
  /* sid:20 */
  while (1) {
    /* sid:22 */
    if (nxt) {
      /* sid:24 */
      if (nxt < f) {
        
      }
      else {
        /* sid:25 */
        break;
      }
    }
    else {
      /* sid:26 */
      break;
    }
    /* sid:27 */
    /*block:begin*/
      {
      /* sid:29 */
      if (nxt + nxt->size == f) {
        /* sid:30 */
        nxt->size += f->size;
        /* sid:31 */
        f = nxt + nxt->size;
        /* sid:33 */
        if (f == nxt->ptr) {
          /* sid:34 */
          nxt->size += f->size;
          /* sid:35 */
          nxt->ptr = f->ptr;
        }
        else {
          
        }
        /* sid:101 */
        /*block:begin*/ { /* sid:102 */
                          goto return_label; } /*block:end*/
      }
      else {
        
      }
    }
    /*block:end*/
    /* sid:39 */
    prev = nxt;
    /* sid:40 */
    nxt = nxt->ptr;
  }
  /* sid:41 */
  prev->ptr = f;
  /* sid:42 */
  prev = f + f->size;
  /* sid:44 */
  if (prev == nxt) {
    /* sid:45 */
    f->size += nxt->size;
    /* sid:46 */
    f->ptr = nxt->ptr;
  }
  else {
    /* sid:47 */
    f->ptr = nxt;
  }
  return_label: /* internal */ /* sid:103 */
  return;
}

void *laAlloc(int nbytes)
{
  /* Locals: __retres, nxt, prev, nunits */
  void *__retres;
  HEADER *nxt;
  HEADER *prev;
  int nunits;
  /* sid:50 */
  nunits = (int)((((unsigned int)nbytes + sizeof(HEADER)) - (unsigned int)1) / sizeof(HEADER) + (unsigned int)1);
  /* sid:51 */
  prev = (HEADER *)0;
  /* sid:52 */
  nxt = frhd;
  /* sid:53 */
  while (1) {
    /* sid:55 */
    if (nxt) {
      
    }
    else {
      /* sid:56 */
      break;
    }
    /* sid:57 */
    /*block:begin*/
      {
      /* sid:59 */
      if (nxt->size >= (unsigned int)nunits) {
        /* sid:61 */
        if (nxt->size > (unsigned int)nunits) {
          /* sid:62 */
          nxt->size -= (unsigned int)nunits;
          /* sid:63 */
          nxt += nxt->size;
          /* sid:64 */
          nxt->size = (unsigned int)nunits;
        }
        else {
          /* sid:66 */
          if (prev == (HEADER *)0) {
            /* sid:67 */
            frhd = nxt->ptr;
          }
          else {
            /* sid:68 */
            prev->ptr = nxt->ptr;
          }
        }
        /* sid:69 */
        memleft = (short)((int)memleft - nunits);
        /* sid:105 */
        /*block:begin*/
          {
          /* sid:71 */
          __retres = (void *)(nxt + 1);
          /* sid:106 */
          goto return_label;
        }
        /*block:end*/
      }
      else {
        
      }
    }
    /*block:end*/
    /* sid:73 */
    prev = nxt;
    /* sid:74 */
    nxt = nxt->ptr;
  }
  /* sid:75 */
  warm_boot((char *)"Allocation Failed!");
  /* sid:76 */
  __retres = (void *)0;
  return_label: /* internal */ /* sid:107 */
  return __retres;
}

void laInit(void)
{
  /* sid:78 */
  _heapstart.ptr = (struct hdr *)sbrk(65360);
  /* sid:79 */
  _heapend.ptr = (struct hdr *)sbrk(0);
  /* sid:80 */
  frhd = _heapstart.ptr;
  /* sid:81 */
  frhd->ptr = (struct hdr *)0;
  /* sid:82 */
  frhd->size = (unsigned int)((char *)_heapend.ptr - (char *)_heapstart.ptr) / sizeof(HEADER);
  /* sid:83 */
  memleft = (short)frhd->size;
  /* sid:109 */
  return;
}

/*@ type cty = HEADER *;
 */
/*@ logic cty cbe{L}= _heapstart.ptr;
 */
/*@ logic cty cen{L}= _heapend.ptr;
 */
/*@ logic â„¤ csz{L}(cty x) = \at(x->size * sizeof(HEADER),L);
 */
/*@ logic cty fbe{L}= frhd;
 */
/*@ logic cty fen= \null;
 */
/*@ logic cty fn{L}(cty x) = \at(x->ptr,L);
 */
/*@ logic char * malloc= "laAlloc";
 */
/*@ logic char * minit= "laInit";
 */
/*@ logic char * free= "laFree";

*/
int main(void)
{
  /* Locals: __retres, man, p1, p2 */
  int __retres;
  /* sid:86 */
  laInit();
  /* sid:87 */
  void *man = (void *)0;
  /* sid:88 */
  void *p1 = laAlloc(20);
  /* sid:89 */
  laAlloc(20);
  /* sid:90 */
  void *p2 = laAlloc(20);
  /* sid:91 */
  laAlloc(20);
  /* sid:92 */
  laFree(p1);
  /* sid:93 */
  laFree(p2);
  /* sid:94 */
  __retres = 0;
  /* sid:111 */
  return __retres;
}


