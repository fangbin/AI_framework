/* Generated by Frama-C */
typedef int wchar_t;
typedef unsigned int size_t;
typedef int ssize_t;
typedef unsigned int uid_t;
typedef int intptr_t;
typedef long time_t;
struct __anonstruct_fd_set_1 {
   char __fc_fd_set ;
};
typedef struct __anonstruct_fd_set_1 fd_set;
typedef unsigned int clock_t;
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
};
struct option {
   char const *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
typedef long Align;
struct __anonstruct_s_5 {
   union header *ptr ;
   unsigned int size ;
};
union header {
   struct __anonstruct_s_5 s ;
   Align x ;
};
typedef union header Header;
void krFree(void *ap);

void *krAlloc(unsigned int nbytes);

/*@
axiomatic MemCmp {
  logic ℤ memcmp{L1, L2}(char *s1, char *s2, ℤ n) 
    reads \at(*(s1+(0 .. n-1)),L1), \at(*(s2+(0 .. n-1)),L2);
  
  axiom memcmp_zero{L1, L2}:
    ∀ char *s1, char *s2;
    ∀ ℤ n;
      memcmp{L1, L2}(s1, s2, n) ≡ 0 ⇔
      (∀ ℤ i; 0 ≤ i ∧ i < n ⇒ \at(*(s1+i),L1) ≡ \at(*(s2+i),L2));
  
  }
 */
/*@
axiomatic MemChr {
  logic 𝔹 memchr{L}(char *s, ℤ c, ℤ n) 
    reads *(s+(0 .. n-1));
  
  axiom memchr_def{L}:
    ∀ char *s;
    ∀ ℤ c;
    ∀ ℤ n;
      memchr{L}(s, c, n) ≡ \true ⇔
      (∃ int i; (0 ≤ i ∧ i < n) ∧ *(s+i) ≡ c);
  
  }
 */
/*@
axiomatic MemSet {
  logic 𝔹 memset{L}(char *s, ℤ c, ℤ n) 
    reads *(s+(0 .. n-1));
  
  axiom memset_def{L}:
    ∀ char *s;
    ∀ ℤ c;
    ∀ ℤ n;
      memset{L}(s, c, n) ≡ \true ⇔
      (∀ ℤ i; 0 ≤ i ∧ i < n ⇒ *(s+i) ≡ c);
  
  }
 */
/*@
axiomatic StrLen {
  logic ℤ strlen{L}(char *s) 
    reads *(s+(0 ..));
  
  axiom strlen_pos_or_null{L}:
    ∀ char *s;
    ∀ ℤ i;
      (0 ≤ i ∧ (∀ ℤ j; 0 ≤ j ∧ j < i ⇒ *(s+j) ≢ '\000')) ∧
      *(s+i) ≡ '\000' ⇒ strlen{L}(s) ≡ i;
  
  axiom strlen_neg{L}:
    ∀ char *s;
      (∀ ℤ i; 0 ≤ i ⇒ *(s+i) ≢ '\000') ⇒ strlen{L}(s) < 0;
  
  axiom strlen_before_null{L}:
    ∀ char *s;
    ∀ ℤ i; 0 ≤ i ∧ i < strlen{L}(s) ⇒ *(s+i) ≢ '\000';
  
  axiom strlen_at_null{L}:
    ∀ char *s; 0 ≤ strlen{L}(s) ⇒ *(s+strlen{L}(s)) ≡ '\000';
  
  axiom strlen_not_zero{L}:
    ∀ char *s;
    ∀ ℤ i;
      (0 ≤ i ∧ i ≤ strlen{L}(s)) ∧ *(s+i) ≢ '\000' ⇒
      i < strlen{L}(s);
  
  axiom strlen_zero{L}:
    ∀ char *s;
    ∀ ℤ i;
      (0 ≤ i ∧ i ≤ strlen{L}(s)) ∧ *(s+i) ≡ '\000' ⇒
      i ≡ strlen{L}(s);
  
  axiom strlen_sup{L}:
    ∀ char *s;
    ∀ ℤ i;
      0 ≤ i ∧ *(s+i) ≡ '\000' ⇒
      0 ≤ strlen{L}(s) ∧ strlen{L}(s) ≤ i;
  
  axiom strlen_shift{L}:
    ∀ char *s;
    ∀ ℤ i;
      0 ≤ i ∧ i ≤ strlen{L}(s) ⇒ strlen{L}(s+i) ≡ strlen{L}(s)-i;
  
  axiom strlen_create{L}:
    ∀ char *s;
    ∀ ℤ i;
      0 ≤ i ∧ *(s+i) ≡ '\000' ⇒
      0 ≤ strlen{L}(s) ∧ strlen{L}(s) ≤ i;
  
  axiom strlen_create_shift{L}:
    ∀ char *s;
    ∀ ℤ i;
    ∀ ℤ k;
      (0 ≤ k ∧ k ≤ i) ∧ *(s+i) ≡ '\000' ⇒
      0 ≤ strlen{L}(s+k) ∧ strlen{L}(s+k) ≤ i-k;
  
  axiom memcmp_strlen_left{L}:
    ∀ char *s1, char *s2;
    ∀ ℤ n;
      memcmp{L, L}(s1, s2, n) ≡ 0 ∧ strlen{L}(s1) < n ⇒
      strlen{L}(s1) ≡ strlen{L}(s2);
  
  axiom memcmp_strlen_right{L}:
    ∀ char *s1, char *s2;
    ∀ ℤ n;
      memcmp{L, L}(s1, s2, n) ≡ 0 ∧ strlen{L}(s2) < n ⇒
      strlen{L}(s1) ≡ strlen{L}(s2);
  
  axiom memcmp_strlen_shift_left{L}:
    ∀ char *s1, char *s2;
    ∀ ℤ k, ℤ n;
      (memcmp{L, L}(s1, s2+k, n) ≡ 0 ∧ 0 ≤ k) ∧ strlen{L}(s1) < n ⇒
      0 ≤ strlen{L}(s2) ∧ strlen{L}(s2) ≤ k+strlen{L}(s1);
  
  axiom memcmp_strlen_shift_right{L}:
    ∀ char *s1, char *s2;
    ∀ ℤ k, ℤ n;
      (memcmp{L, L}(s1+k, s2, n) ≡ 0 ∧ 0 ≤ k) ∧ strlen{L}(s2) < n ⇒
      0 ≤ strlen{L}(s1) ∧ strlen{L}(s1) ≤ k+strlen{L}(s2);
  
  }
 */
/*@
axiomatic StrCmp {
  logic ℤ strcmp{L}(char *s1, char *s2) 
    reads *(s1+(0 .. strlen{L}(s1))), *(s2+(0 .. strlen{L}(s2)));
  
  axiom strcmp_zero{L}:
    ∀ char *s1, char *s2;
      strcmp{L}(s1, s2) ≡ 0 ⇔
      strlen{L}(s1) ≡ strlen{L}(s2) ∧
      (∀ ℤ i; 0 ≤ i ∧ i ≤ strlen{L}(s1) ⇒ *(s1+i) ≡ *(s2+i));
  
  }
 */
/*@
axiomatic StrNCmp {
  logic ℤ strncmp{L}(char *s1, char *s2, ℤ n) 
    reads *(s1+(0 .. n-1)), *(s2+(0 .. n-1));
  
  axiom strncmp_zero{L}:
    ∀ char *s1, char *s2;
    ∀ ℤ n;
      strncmp{L}(s1, s2, n) ≡ 0 ⇔
      (strlen{L}(s1) < n ∧ strcmp{L}(s1, s2) ≡ 0) ∨
      (∀ ℤ i; 0 ≤ i ∧ i < n ⇒ *(s1+i) ≡ *(s2+i));
  
  }
 */
/*@
axiomatic StrChr {
  logic 𝔹 strchr{L}(char *s, ℤ c) 
    reads *(s+(0 .. strlen{L}(s)));
  
  axiom strchr_def{L}:
    ∀ char *s;
    ∀ ℤ c;
      strchr{L}(s, c) ≡ \true ⇔
      (∃ ℤ i; (0 ≤ i ∧ i ≤ strlen{L}(s)) ∧ *(s+i) ≡ c);
  
  }
 */
/*@
axiomatic WcsLen {
  logic ℤ wcslen{L}(wchar_t *s) 
    reads *(s+(0 ..));
  
  axiom wcslen_pos_or_null{L}:
    ∀ wchar_t *s;
    ∀ ℤ i;
      (0 ≤ i ∧ (∀ ℤ j; 0 ≤ j ∧ j < i ⇒ *(s+j) ≢ 0)) ∧
      *(s+i) ≡ 0 ⇒ wcslen{L}(s) ≡ i;
  
  axiom wcslen_neg{L}:
    ∀ wchar_t *s;
      (∀ ℤ i; 0 ≤ i ⇒ *(s+i) ≢ 0) ⇒ wcslen{L}(s) < 0;
  
  axiom wcslen_before_null{L}:
    ∀ wchar_t *s;
    ∀ int i; 0 ≤ i ∧ i < wcslen{L}(s) ⇒ *(s+i) ≢ 0;
  
  axiom wcslen_at_null{L}:
    ∀ wchar_t *s; 0 ≤ wcslen{L}(s) ⇒ *(s+wcslen{L}(s)) ≡ 0;
  
  axiom wcslen_not_zero{L}:
    ∀ wchar_t *s;
    ∀ int i;
      (0 ≤ i ∧ i ≤ wcslen{L}(s)) ∧ *(s+i) ≢ 0 ⇒ i < wcslen{L}(s);
  
  axiom wcslen_zero{L}:
    ∀ wchar_t *s;
    ∀ int i;
      (0 ≤ i ∧ i ≤ wcslen{L}(s)) ∧ *(s+i) ≡ 0 ⇒
      i ≡ wcslen{L}(s);
  
  axiom wcslen_sup{L}:
    ∀ wchar_t *s;
    ∀ int i;
      0 ≤ i ∧ *(s+i) ≡ 0 ⇒ 0 ≤ wcslen{L}(s) ∧ wcslen{L}(s) ≤ i;
  
  axiom wcslen_shift{L}:
    ∀ wchar_t *s;
    ∀ int i;
      0 ≤ i ∧ i ≤ wcslen{L}(s) ⇒ wcslen{L}(s+i) ≡ wcslen{L}(s)-i;
  
  axiom wcslen_create{L}:
    ∀ wchar_t *s;
    ∀ int i;
      0 ≤ i ∧ *(s+i) ≡ 0 ⇒ 0 ≤ wcslen{L}(s) ∧ wcslen{L}(s) ≤ i;
  
  axiom wcslen_create_shift{L}:
    ∀ wchar_t *s;
    ∀ int i;
    ∀ int k;
      (0 ≤ k ∧ k ≤ i) ∧ *(s+i) ≡ 0 ⇒
      0 ≤ wcslen{L}(s+k) ∧ wcslen{L}(s+k) ≤ i-k;
  
  }
 */
/*@
axiomatic WcsCmp {
  logic ℤ wcscmp{L}(wchar_t *s1, wchar_t *s2) 
    reads *(s1+(0 .. wcslen{L}(s1))), *(s2+(0 .. wcslen{L}(s2)));
  
  axiom wcscmp_zero{L}:
    ∀ wchar_t *s1, wchar_t *s2;
      wcscmp{L}(s1, s2) ≡ 0 ⇔
      wcslen{L}(s1) ≡ wcslen{L}(s2) ∧
      (∀ ℤ i; 0 ≤ i ∧ i ≤ wcslen{L}(s1) ⇒ *(s1+i) ≡ *(s2+i));
  
  }
 */
/*@
axiomatic WcsNCmp {
  logic ℤ wcsncmp{L}(wchar_t *s1, wchar_t *s2, ℤ n) 
    reads *(s1+(0 .. n-1)), *(s2+(0 .. n-1));
  
  axiom wcsncmp_zero{L}:
    ∀ wchar_t *s1, wchar_t *s2;
    ∀ ℤ n;
      wcsncmp{L}(s1, s2, n) ≡ 0 ⇔
      (wcslen{L}(s1) < n ∧ wcscmp{L}(s1, s2) ≡ 0) ∨
      (∀ ℤ i; 0 ≤ i ∧ i < n ⇒ *(s1+i) ≡ *(s2+i));
  
  }
 */
/*@ logic ℤ minimum(ℤ i, ℤ j) = i<j? i: j;
 */
/*@ logic ℤ maximum(ℤ i, ℤ j) = i<j? j: i;
 */
/*@
predicate valid_string{L}(char *s) =
  0 ≤ strlen{L}(s) ∧ \valid{L}(s+(0 .. strlen{L}(s)));
 */
/*@
predicate valid_read_string{L}(char *s) =
  0 ≤ strlen{L}(s) ∧ \valid_read{L}(s+(0 .. strlen{L}(s)));
 */
/*@
predicate valid_string_or_null{L}(char *s) =
  s ≡ \null ∨ valid_string{L}(s);
 */
/*@
predicate valid_wstring{L}(wchar_t *s) =
  0 ≤ wcslen{L}(s) ∧ \valid{L}(s+(0 .. wcslen{L}(s)));
 */
/*@
predicate valid_wstring_or_null{L}(wchar_t *s) =
  s ≡ \null ∨ valid_wstring{L}(s);
 */
/*@ assigns *fdset;
    assigns *fdset \from *fdset, fd; */
extern void FD_CLR(int fd, fd_set *fdset);

/*@ assigns \nothing; */
extern int FD_ISSET(int fd, fd_set *fdset);

/*@ assigns *fdset;
    assigns *fdset \from *fdset, fd; */
extern void FD_SET(int fd, fd_set *fdset);

/*@ assigns *fdset;
    assigns *fdset \from \nothing; */
extern void FD_ZERO(fd_set *fdset);

/*@ ghost unsigned int volatile __fc_time __attribute__((__FRAMA_C_MODEL__));
  */
/*@ assigns \result;
    assigns \result \from __fc_time; */
extern clock_t clock(void);

/*@ assigns \result;
    assigns \result \from time1, time0; */
extern double difftime(time_t time1, time_t time0);

/*@ assigns *timeptr, \result;
    assigns *timeptr \from *timeptr;
    assigns \result \from *timeptr;
 */
extern time_t mktime(struct tm *timeptr);

/*@ assigns *timer, \result;
    assigns *timer \from __fc_time;
    assigns \result \from __fc_time;
    
    behavior null:
      assumes /* ip:6 */timer ≡ \null;
      assigns \result;
      assigns \result \from __fc_time;
    
    behavior not_null:
      assumes /* ip:8 */timer ≢ \null;
      requires /* ip:9 */\valid{Here}(timer);
      ensures /* ip:7 */\initialized{Here}(\old(timer));
      assigns *timer, \result;
      assigns *timer \from __fc_time;
      assigns \result \from __fc_time;
    
    complete behaviors not_null, null;
    disjoint behaviors not_null, null;
 */
extern time_t time(time_t *timer);

struct tm __fc_time_tm;
struct tm * const __p_fc_time_tm = & __fc_time_tm;
/*@ ensures /* ip:10 */\result ≡ &__fc_time_tm ∨ \result ≡ \null;
    assigns \result, __fc_time_tm;
    assigns \result \from __p_fc_time_tm;
    assigns __fc_time_tm \from *timer;
 */
extern struct tm *gmtime(time_t const *timer);

/*@ ensures /* ip:11 */\result ≡ &__fc_time_tm ∨ \result ≡ \null;
    assigns \result, __fc_time_tm;
    assigns \result \from __p_fc_time_tm;
    assigns __fc_time_tm \from *timer;
 */
extern struct tm *localtime(time_t const *timer);

extern char *optarg;

extern int optind;

extern int opterr;

extern int optopt;

/*@ assigns \result, *optarg, optind, opterr, optopt;
    assigns \result \from argc, *(argv+(0 .. argc-1)), *(optstring+(0 ..));
    assigns *optarg \from argc, *(argv+(0 .. argc-1)), *(optstring+(0 ..));
    assigns optind \from argc, *(argv+(0 .. argc-1)), *(optstring+(0 ..));
    assigns opterr \from argc, *(argv+(0 .. argc-1)), *(optstring+(0 ..));
    assigns optopt \from argc, *(argv+(0 .. argc-1)), *(optstring+(0 ..));
 */
extern int getopt(int argc, char * const *argv, char const *optstring);

/*@ assigns \result, *optarg, optind, opterr, optopt,
            *((longopts+(0 ..))->flag);
    assigns \result
      \from argc, *(argv+(0 .. argc-1)), *(shortopts+(0 ..)),
            *(longopts+(0 ..));
    assigns *optarg
      \from argc, *(argv+(0 .. argc-1)), *(shortopts+(0 ..)),
            *(longopts+(0 ..));
    assigns optind
      \from argc, *(argv+(0 .. argc-1)), *(shortopts+(0 ..)),
            *(longopts+(0 ..));
    assigns opterr
      \from argc, *(argv+(0 .. argc-1)), *(shortopts+(0 ..)),
            *(longopts+(0 ..));
    assigns optopt
      \from argc, *(argv+(0 .. argc-1)), *(shortopts+(0 ..)),
            *(longopts+(0 ..));
    assigns *((longopts+(0 ..))->flag)
      \from argc, *(argv+(0 .. argc-1)), *(shortopts+(0 ..)),
            *(longopts+(0 ..));
 */
extern int getopt_long(int argc, char * const *argv, char const *shortopts,
                       struct option const *longopts, int *longind);

/*@ assigns \result, *optarg, optind, opterr, optopt,
            *((longopts+(0 ..))->flag);
    assigns \result
      \from argc, *(argv+(0 .. argc-1)), *(shortopts+(0 ..)),
            *(longopts+(0 ..));
    assigns *optarg
      \from argc, *(argv+(0 .. argc-1)), *(shortopts+(0 ..)),
            *(longopts+(0 ..));
    assigns optind
      \from argc, *(argv+(0 .. argc-1)), *(shortopts+(0 ..)),
            *(longopts+(0 ..));
    assigns opterr
      \from argc, *(argv+(0 .. argc-1)), *(shortopts+(0 ..)),
            *(longopts+(0 ..));
    assigns optopt
      \from argc, *(argv+(0 .. argc-1)), *(shortopts+(0 ..)),
            *(longopts+(0 ..));
    assigns *((longopts+(0 ..))->flag)
      \from argc, *(argv+(0 .. argc-1)), *(shortopts+(0 ..)),
            *(longopts+(0 ..));
 */
extern int getopt_long_only(int argc, char * const *argv,
                            char const *shortopts,
                            struct option const *longopts, int *longind);

/*@ ghost int __fc_fds[1024]; */
/*@ requires /* ip:13 */0 ≤ fd ∧ fd < 1024;
    ensures /* ip:12 */\result ≡ 0 ∨ \result ≡ -1;
    assigns \result, __fc_fds[fd];
    assigns \result \from fd, __fc_fds[fd];
    assigns __fc_fds[fd] \from fd, __fc_fds[fd];
 */
extern int close(int fd);

/*@ requires /* ip:14 */arg ≢ \null;
    requires /* ip:15 */valid_read_string{Here}(path);
    requires /* ip:16 */valid_read_string{Here}(arg);
    assigns \result;
    assigns \result \from *(path+(0 ..)), *(arg+(0 ..));
 */
extern int execl(char const *path, char const *arg , ...);

/*@ requires /* ip:17 */arg ≢ \null;
    requires /* ip:18 */valid_read_string{Here}(path);
    requires /* ip:19 */valid_read_string{Here}(arg);
    assigns \result;
    assigns \result \from *(path+(0 ..)), *(arg+(0 ..));
 */
extern int execle(char const *path, char const *arg , ...);

/*@ requires /* ip:20 */arg ≢ \null;
    requires /* ip:21 */valid_read_string{Here}(path);
    requires /* ip:22 */valid_read_string{Here}(arg);
    assigns \result;
    assigns \result \from *(path+(0 ..)), *(arg+(0 ..));
 */
extern int execlp(char const *path, char const *arg , ...);

/*@ requires /* ip:23 */*(argv+0) ≢ \null;
    requires /* ip:24 */valid_read_string{Here}(path);
    requires /* ip:25 */valid_read_string{Here}(*(argv+0));
    assigns \result;
    assigns \result \from *(path+(0 ..)), *(argv+(0 ..));
 */
extern int execv(char const *path, char * const *argv);

/*@ requires /* ip:26 */*(argv+0) ≢ \null;
    requires /* ip:27 */valid_read_string{Here}(path);
    requires /* ip:28 */valid_read_string{Here}(*(argv+0));
    assigns \result;
    assigns \result \from *(path+(0 ..)), *(argv+(0 ..));
 */
extern int execve(char const *path, char * const *argv, char * const *env);

/*@ requires /* ip:29 */*(argv+0) ≢ \null;
    requires /* ip:30 */valid_read_string{Here}(path);
    requires /* ip:31 */valid_read_string{Here}(*(argv+0));
    assigns \result;
    assigns \result \from *(path+(0 ..)), *(argv+(0 ..));
 */
extern int execvp(char const *path, char * const *argv);

/*@ assigns \result;
    assigns \result \from \nothing; */
extern uid_t getuid(void);

/*@ requires /* ip:34 */0 ≤ fd ∧ fd < 1024;
    requires /* ip:35 */\valid{Here}((char *)buf+(0 .. count-1));
    ensures
      /* ip:32 */(0 ≤ \result ∧ \result ≤ \old(count)) ∨
                 \result ≡ -1;
    ensures
      /* ip:33 */\initialized{Here}((char *)\old(buf)+(0 .. \result-1));
    assigns \result, *((char *)buf+(0 .. count-1)), __fc_fds[fd];
    assigns \result \from __fc_fds[fd], count;
    assigns *((char *)buf+(0 .. count-1)) \from __fc_fds[fd], count;
    assigns __fc_fds[fd] \from __fc_fds[fd], count;
 */
extern ssize_t read(int fd, void *buf, size_t count);

extern void *sbrk(intptr_t);

/*@ requires /* ip:37 */0 ≤ fd ∧ fd < 1024;
    requires /* ip:38 */\valid_read{Here}((char *)buf+(0 .. count-1));
    ensures /* ip:36 */-1 ≤ \result ∧ \result ≤ \old(count);
    assigns \result, __fc_fds[fd];
    assigns \result \from fd, count, __fc_fds[fd];
    assigns __fc_fds[fd] \from fd, count, __fc_fds[fd];
 */
extern ssize_t write(int fd, void const *buf, size_t count);

static Header base;
static Header *freep = (Header *)0;
Header *morecore(unsigned int nu);

void *krAlloc(unsigned int nbytes)
{
  /* Locals: __retres, p, prevp, nunits */
  void *__retres;
  Header *p;
  Header *prevp;
  unsigned int nunits;
  /* sid:1 */
  nunits = ((nbytes + sizeof(Header)) - (unsigned int)1) / sizeof(Header) + (unsigned int)1;
  /* sid:2 */
  prevp = freep;
  /* sid:3 */
  if (prevp == (Header *)0) {
    /* sid:4 */
    { /* sequence */
      /* sid:5 */
      prevp = & base;
      /*effects: (freep, prevp) prevp <- base, base*/
      /* sid:6 */
      freep = prevp;
      /*effects: (freep) freep <- */
      /* sid:7 */
      base.s.ptr = freep;
      /*effects: (base.s.ptr) base.s.ptr <- */
    }
    /* sid:8 */
    base.s.size = (unsigned int)0;
  }
  else {
    
  }
  /* sid:10 */
  p = prevp->s.ptr;
  /* sid:11 */
  while (1) {
    /* sid:12 */
    /*block:begin*/
      {
      /* sid:14 */
      if (p->s.size >= nunits) {
        /* sid:16 */
        if (p->s.size == nunits) {
          /* sid:17 */
          prevp->s.ptr = p->s.ptr;
        }
        else {
          /* sid:18 */
          p->s.size -= nunits;
          /* sid:19 */
          p += p->s.size;
          /* sid:20 */
          p->s.size = nunits;
        }
        /* sid:21 */
        freep = prevp;
        /* sid:23 */
        __retres = (void *)(p + 1);
        /* sid:91 */
        goto return_label;
      }
      else {
        
      }
      /* sid:26 */
      if (p == freep) {
        /* sid:27 */
        p = morecore(nunits);
        /* sid:28 */
        if (p == (Header *)0) {
          /* sid:29 */
          __retres = (void *)0;
          /* sid:92 */
          goto return_label;
        }
        else {
          
        }
      }
      else {
        
      }
    }
    /*block:end*/
    /* sid:32 */
    prevp = p;
    /* sid:33 */
    p = p->s.ptr;
  }
  return_label: /* internal */ /* sid:93 */
                               return __retres;
}

Header *morecore(unsigned int nu)
{
  /* Locals: __retres, cp, up */
  Header *__retres;
  char *cp;
  Header *up;
  /* sid:36 */
  if (nu < (unsigned int)1024) {
    /* sid:37 */
    nu = (unsigned int)1024;
  }
  else {
    
  }
  /* sid:39 */
  cp = (char *)sbrk((int)(nu * sizeof(Header)));
  /* sid:41 */
  if (cp == (char *)(-1)) {
    /* sid:42 */
    __retres = (Header *)0;
    /* sid:95 */
    goto return_label;
  }
  else {
    
  }
  /* sid:44 */
  up = (Header *)cp;
  /* sid:45 */
  up->s.size = nu;
  /* sid:46 */
  krFree((void *)(up + 1));
  /* sid:48 */
  __retres = freep;
  return_label: /* internal */ /* sid:96 */
                               return __retres;
}

void krFree(void *ap)
{
  /* Locals: bp, p */
  Header *bp;
  Header *p;
  /* sid:50 */
  bp = (Header *)ap - 1;
  /* sid:51 */
  p = freep;
  /* sid:52 */
  while (1) {
    /* sid:54 */
    if (bp > p) {
      /* sid:56 */
      if (bp < p->s.ptr) {
        /* sid:57 */
        break;
      }
      else {
        
      }
    }
    else {
      
    }
    /* sid:59 */
    if (p >= p->s.ptr) {
      /* sid:61 */
      if (bp > p) {
        /* sid:62 */
        break;
      }
      else {
        /* sid:64 */
        if (bp < p->s.ptr) {
          /* sid:65 */
          break;
        }
        else {
          
        }
      }
    }
    else {
      
    }
    /* sid:68 */
    p = p->s.ptr;
  }
  /* sid:70 */
  if (bp + bp->s.size == p->s.ptr) {
    /* sid:71 */
    bp->s.size += (p->s.ptr)->s.size;
    /* sid:72 */
    bp->s.ptr = (p->s.ptr)->s.ptr;
  }
  else {
    /* sid:73 */
    bp->s.ptr = p->s.ptr;
  }
  /* sid:75 */
  if (p + p->s.size == bp) {
    /* sid:76 */
    p->s.size += bp->s.size;
    /* sid:77 */
    p->s.ptr = bp->s.ptr;
  }
  else {
    /* sid:78 */
    p->s.ptr = bp;
  }
  /* sid:79 */
  freep = p;
  /* sid:98 */
  return;
}

/*@ type cty = Header *;
 */
/*@ logic ℤ csz{L}(cty x) = \at(x->s.size,L);
 */
/*@ logic cty fn{L}(cty x) = \at(x->s.ptr,L);
 */
/*@ logic char * malloc= "krAlloc";
 */
/*@ logic char * minit= "morecore";
 */
/*@ logic char * mfree= "krFree";

*/
int main(void)
{
  /* Locals: __retres, man, p1, p2 */
  int __retres;
  void *man;
  void *p1;
  void *p2;
  /* sid:82 */
  man = (void *)0;
  /* sid:83 */
  p1 = krAlloc((unsigned int)20);
  /* sid:84 */
  krAlloc((unsigned int)20);
  /* sid:85 */
  p2 = krAlloc((unsigned int)20);
  /* sid:86 */
  krAlloc((unsigned int)20);
  /* sid:87 */
  krFree(p1);
  /* sid:88 */
  krFree(p2);
  /* sid:89 */
  __retres = 0;
  /* sid:100 */
  return __retres;
}


