##########################################################################
#                                                                        #
#  This file is part of Frama-C.                                         #
#                                                                        #
#  Copyright (C) 2007-2018                                               #
#    CEA (Commissariat à l'énergie atomique et aux énergies              #
#         alternatives)                                                  #
#                                                                        #
#  you can redistribute it and/or modify it under the terms of the GNU   #
#  Lesser General Public License as published by the Free Software       #
#  Foundation, version 2.1.                                              #
#                                                                        #
#  It is distributed in the hope that it will be useful,                 #
#  but WITHOUT ANY WARRANTY; without even the implied warranty of        #
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         #
#  GNU Lesser General Public License for more details.                   #
#                                                                        #
#  See the GNU Lesser General Public License version 2.1                 #
#  for more details (enclosed in the file licenses/LGPLv2.1).            #
#                                                                        #
##########################################################################

###############################################################################
#
# Generic makefile used to build plug-ins.
# Setup the following required variables before including this makefile:
#
# Warning: You should not use these variables inside of your Makefile,
# use the namespaced version (Hello_*) at the end of this list.
#
# Usual information
# -----------------
ifndef PLUGIN_NAME # The ML module name of the plugin
  $(error PLUGIN_NAME is not set)
endif
ifndef PLUGIN_DIR # The directory containing the source files
  $(error PLUGIN_DIR is not set)
endif
PLUGIN_DIR?=
PLUGIN_ENABLE?=  # Whether the plugin is enabled
PLUGIN_DEPENDS?= # Deprecated (static plug-in dependencies, Frama-C only)

# META file
# ---------
# The META for the plug-in is automatically generated, unless variable
# PLUGIN_HAS_META is set to "yes". The following optional variables can
# be set accordingly:
#
PLUGIN_HAS_META?=     # defaults to empty

# When setting PLUGIN_HAS_META to "yes", the next variables are not taken into
# account. Instead, your are responsible for providing a full featured META
# file in the PLUGIN_DIR source directory, which will be copied and installed
# with the plug-in object files.

PLUGIN_DESCRIPTION?=  # if empty then defaults to "Frama-C NAME plug-in"
PLUGIN_VERSION?=      # if empty then defaults to current Frama-C version
PLUGIN_REQUIRES?=     # package(s) the plug-in depends on (defaults to empty)
PLUGIN_DEPENDENCIES?= # plugins(s) the plug-in depends on (defaults to empty)

# Remarks:
# - the package name for "MyPlugin" is defined to be "frama-c-myplugin"
# - PLUGIN_DEPENDENCIES <pkg> is a shortcut for PLUGIN_REQUIRES <frama-c-pkg>
# - the makefile adds a proper "directory" directive to both provided or
#   generated META files


# Source files
# ------------
PLUGIN_CMO?=       # The .cmo files (do not add the plugin path and the
                   # extension)
PLUGIN_CMI?=       # The .cmi files (only if there is no corresponding .cmo)
PLUGIN_TYPES_CMO?= # The .cmo files containing the types definitions
PLUGIN_GUI_CMI?=   # The .cmi files for the GUI
                   # (only if there is no corresponding .cmi)
PLUGIN_GUI_CMO?=   # The .cmo files to be linked with the graphical interface
PLUGIN_GENERATED?= # source files generated by the plugins, typically parsers

# Compilation flags
# -----------------
PLUGIN_BFLAGS?=          # Additional options for the bytecode compiler
PLUGIN_OFLAGS?=          # Additional options for the native compiler
PLUGIN_EXTRA_BYTE?=      # Additional bytecode files to link against
PLUGIN_EXTRA_OPT?=       # Additional native files to link against
PLUGIN_EXTRA_DIRS?=      # Additional directories (relative to the root of the
                         # plugin) containing some of the source files of the
                         # plugin
PLUGIN_LINK_BFLAGS?=     # Additional options for the bytecode linker
PLUGIN_LINK_OFLAGS?=     # Additional options for the native linker
PLUGIN_LINK_GUI_BFLAGS?= # Additional options for the bytecode gui linker
PLUGIN_LINK_GUI_OFLAGS?= # Additional options for the native gui linker


# Dependencies
# ------------
PLUGIN_DEPFLAGS?= # Additional options for ocamldep

# Documentation
# -------------
PLUGIN_DOCFLAGS?=    # Additional options for ocamldoc
PLUGIN_UNDOC?=       # Do not document this source files (do not add the
                     # plugin path)
PLUGIN_TYPES_TODOC?= # Do document this source files containing the types
                     # definition
PLUGIN_INTRO?=       # Add this text file to the introduction of the
                     # documentation
PLUGIN_HAS_EXT_DOC?= # (yes/no) Plugin has a pdf manual


# Testing
# -------
PLUGIN_NO_TEST?= # Set it to a non-empty value if there is no specific
                 # test directory for this plugin
PLUGIN_TESTS_DIRS?= # Test directories of the plugin.
                    # Default is tests/$(PLUGIN_DIR)
PLUGIN_TESTS_DIRS_DEFAULTS?= # Tests directories that should be run by default
                             # Defaults to $(PLUGIN_TESTS_DIRS)
PLUGIN_TESTS_LIB?= # Additional source (.ml) files used by tests.
PLUGIN_NO_DEFAULT_TEST?= # Set it to a non-empty value if you don't want the
                         # tests of your plugin to be executed systematically
                         # by make tests
PLUGIN_INTERNAL_TEST?= # Set it to a non-empty value if the tests of the plugin
                       # are in Frama-C's tests directory and not a tests
	               # subdirectory of the plugin (internal use only,
                       # obsolete and not recommended way to handle tests)

# Distribution
# ------------
PLUGIN_DISTRIBUTED?= # should the plugin be included in the distribution
                     # (yes/no)
PLUGIN_DISTRIB_EXTERNAL?= # list of files that should be distributed within the
                          # source distribution for this plug-in. They will be
                          # put at their proper place in the frama-c-$(VERSION)
                          # directory for a release.
PLUGIN_DISTRIB_TESTS?= # list of files that should be also distributed without
                       # headers checking.
PLUGIN_HEADER_SPEC?=$(DEFAULT_HEADER_SPEC) # list of files containing header
                                           # specifications.
PLUGIN_HEADER_DIRS?=$(DEFAULT_HEADER_DIRS) # list of directories containing
                                           # open/close-source header files.
PLUGIN_HEADER_EXCEPTIONS?=$(DEFAULT_HEADER_EXCEPTIONS) # list of distributed files allowed
                                                       # to have no entry into the
                                                       # PLUGIN_HEADER_SPEC files
PLUGIN_CEA_PROPRIETARY_FILES?=$(DEFAULT_CEA_PROPRIETARY_FILES) # list of files that cannot be
                                                               # part of an OPEN_SOURCE distribution
PLUGIN_CEA_PROPRIETARY_HEADERS?= # list of licenses that cannot
                                 # be part of an OPEN_SOURCE distribution.

# Kernel developers only
# ----------------------
PLUGIN_RESET?=yes # Set it to no in order to NOT reset plug-in variable.


# Except for their initialization, all these variables should not be used
# outside of this Makefile.
#
# Instead, you can safely use the corresponding following variables.
# Warning:
#   - They contain the extensions and the plugin path unlike the originals
#   - except Hello_DIR, they are undefined before
#     Makefile.plugin.generated is created
#
# Hello_DIR
# Hello_CMO
# Hello_CMX
# Hello_CMI
# Hello_TYPES_CMO
# Hello_TYPES_CMX
# Hello_TYPES_TODOC
# Hello_BFLAGS
# Hello_OFLAGS
# Hello_DEPFLAGS
# Hello_DOCFLAGS
# Hello_GENERATED
# Hello_TESTS_DIRS
# Hello_TESTS_LIB
#
###############################################################################
#
# Note for the Makefile.plugin developers:
# If you add a new option to communicate with the main Makefile,
# don't forget to reset it at the end of this file.
#
###############################################################################

# Where the other plug-ins to load are already installed
ifeq ($(FRAMAC_INTERNAL),yes)
INSTALLED_PLUGIN_DIR:=$(FRAMAC_ROOT_SRCDIR)/lib/plugins
# Also inform the main Makefile that there's another plug-in to be
# considered
PLUGIN_LIST+=$(PLUGIN_DIR)/Hello
else

INSTALLED_PLUGIN_DIR:=$(PLUGIN_INSTALL_DIR)

endif

# The plugin types .cm* files
PLUGIN_TYPES_CMO:=$(addsuffix .cmo,$(PLUGIN_TYPES_CMO))
PLUGIN_TYPES_CMX:=$(PLUGIN_TYPES_CMO:.cmo=.cmx)
Hello_TYPES_CMO:=$(PLUGIN_TYPES_CMO)
Hello_TYPES_CMX:=$(PLUGIN_TYPES_CMX)
Hello_TYPES_TODOC:=$(PLUGIN_TYPES_TODOC)

PLUGIN_TYPES_CMO_LIST += $(PLUGIN_TYPES_CMO)
PLUGIN_TYPES_CMX_LIST += $(PLUGIN_TYPES_CMX)

# [VP] don't exactly know why, but make has a tendency to add a
# spurious space at the beginning of PLUGIN_BASE. Fortunately, $(strip )
# is behaving correctly.
PLUGIN_BASE:=$(strip $(if $(notdir $(PLUGIN_DIR)),$(notdir $(PLUGIN_DIR)),\
$(notdir $(patsubst %/,%,$(PLUGIN_DIR)))))

PLUGIN_DEPENDS:=$(PLUGIN_DEPENDS) $(PLUGIN_DEPENDENCIES)

################
# ml sources   #
################

PLUGIN_SRC:= $(PLUGIN_DIR)/Hello.mli \
	     $(patsubst %,$(PLUGIN_DIR)/%.ml*,$(PLUGIN_CMO)) \
             $(patsubst %,$(PLUGIN_DIR)/%.mli,$(PLUGIN_CMI)) \
             $(patsubst %.cmo,%.ml*,$(PLUGIN_TYPES_CMO))
ifneq ($(ENABLE_GUI),no)
PLUGIN_SRC:= $(PLUGIN_SRC) $(patsubst %,$(PLUGIN_DIR)/%.ml*,$(PLUGIN_GUI_CMO))
endif

Hello_SRC:=$(PLUGIN_SRC)

PLUGIN_ML_SRC:=$(patsubst %.ml*,%.ml,$(PLUGIN_SRC)) \
               $(patsubst %.ml*,%.mli,$(filter %.ml*,$(PLUGIN_SRC)))
Hello_ML_SRC:=$(PLUGIN_ML_SRC)

################
# distribution #
################


ifneq ($(PLUGIN_ENABLE),no)

# for `check-header` target even if the plugin is not distributed
ifneq ("$(strip $(PLUGIN_HEADER_SPEC))","")
# Don't remove the '/./' because it is used as separator:
# i.e. filenames contained into the spec file 'src/plugins/MY-PLUGIN/./headers/header_spec.txt'
# are considered being relative from 'src/plugins/MY-PLUGIN/'.
# The wildcard is used in order to add only existing files.
PLUGIN_HEADER_SPEC_LIST +=$(strip $(wildcard $(PLUGIN_DIR)/./$(PLUGIN_HEADER_SPEC)))
endif

ifneq ("$(strip $(PLUGIN_HEADER_DIRS))","")
# The wildcard is used in order to add only existing directory.
PLUGIN_HEADER_DIRS_LIST +=$(wildcard $(addprefix $(PLUGIN_DIR)/,$(PLUGIN_HEADER_DIRS)))
endif

ifneq ("$(strip $(PLUGIN_HEADER_EXCEPTIONS))","")
PLUGIN_HEADER_EXCEPTIONS_LIST +=$(addprefix $(PLUGIN_DIR)/,$(PLUGIN_HEADER_EXCEPTIONS))
endif

ifneq ("$(strip $(PLUGIN_CEA_PROPRIETARY_HEADERS))","")
PLUGIN_CEA_PROPRIETARY_HEADERS_LIST +=$(PLUGIN_CEA_PROPRIETARY_HEADERS)
endif

ifneq ("$(strip $(PLUGIN_CEA_PROPRIETARY_FILES))","")
# Files that cannot be part of an OPEN_SOURCE distribution.
# The wildcard is used in order to add only existing files.
PLUGIN_CEA_PROPRIETARY_FILE_LIST +=$(wildcard $(addprefix $(PLUGIN_DIR)/,$(PLUGIN_CEA_PROPRIETARY_FILES)))
endif

ifneq ($(PLUGIN_DISTRIBUTED),no)
PLUGIN_DISTRIBUTED_LIST += $(PLUGIN_SRC)

# VP: this needs to be adapted for external plugins.
ifeq ($(PLUGIN_HAS_EXT_DOC),yes)
PLUGIN_EXT_DOC_DIR:=doc/$(PLUGIN_BASE)
PLUGIN_DIST_DOC_LIST += doc/plugins/$(PLUGIN_BASE).pdf
$(PLUGIN_EXT_DOC_DIR)/$(PLUGIN_BASE).pdf:
	$(PRINT_MAKING) $@
	$(MAKE) -C $(dir $@)

doc/plugins/$(PLUGIN_BASE).pdf: \
   $(PLUGIN_EXT_DOC_DIR)/$(PLUGIN_BASE).pdf
	$(PRINT_CP) $<
	$(MKDIR) doc/plugins
	$(CP) $< $@
endif
ifneq ("$(strip $(PLUGIN_DISTRIB_EXTERNAL))","")
PLUGIN_DIST_EXTERNAL_LIST += \
       $(addprefix $(PLUGIN_DIR)/,$(PLUGIN_DISTRIB_EXTERNAL))
endif
ifneq ("$(strip $(PLUGIN_DISTRIB_TESTS))","")
PLUGIN_DIST_TESTS_LIST += \
       $(addprefix $(PLUGIN_DIR)/,$(PLUGIN_DISTRIB_TESTS))
endif
endif #PLUGIN_DISTRIBUTED
endif #PLUGIN_ENABLE

PLUGIN_OPT:=`echo "Hello" | tr 'A-Z' 'a-z' `

# Export some variables which can be safely used outside/inside Makefile.plugin
# even if the plug-in is not enabled
ifneq ("$(PLUGIN_ENABLE)","no")

# The .cm* files list
PLUGIN_CMO:= $(patsubst %,$(PLUGIN_DIR)/%.cmo,$(PLUGIN_CMO))
PLUGIN_CMX:= $(PLUGIN_CMO:.cmo=.cmx)
PLUGIN_CMI_ONLY:=$(patsubst %,$(PLUGIN_DIR)/%.cmi,$(PLUGIN_CMI))
PLUGIN_CMI:= $(PLUGIN_CMI_ONLY) $(PLUGIN_CMO:.cmo=.cmi)
PLUGIN_INFERRED_MLI:= $(PLUGIN_CMO:.cmo=.inferred.mli)

Hello_CMO:=$(PLUGIN_CMO)
Hello_CMX:=$(PLUGIN_CMX)
Hello_CMI_ONLY:=$(PLUGIN_CMI_ONLY)
Hello_CMI:=$(PLUGIN_CMI)
Hello_INFERRED_MLI:=$(PLUGIN_INFERRED_MLI)

HAS_GUI:=no
ifneq  ($(ENABLE_GUI),no)
ifneq ("$(PLUGIN_GUI_CMO)","")
# The .cm* gui files list
PLUGIN_GUI_CMO:= $(PLUGIN_CMO) \
	$(patsubst %,$(PLUGIN_DIR)/%.cmo,$(PLUGIN_GUI_CMO))
PLUGIN_GUI_CMX:= $(PLUGIN_GUI_CMO:.cmo=.cmx)
PLUGIN_GUI_CMI_ONLY:=$(PLUGIN_CMI_ONLY) $(PLUGIN_GUI_CMI)
PLUGIN_GUI_CMI:= $(PLUGIN_CMI_ONLY) $(PLUGIN_GUI_CMO:.cmo=.cmi)
HAS_GUI:=yes
endif
endif

Hello_GUI_CMO:=$(PLUGIN_GUI_CMO)
Hello_GUI_CMX:=$(PLUGIN_GUI_CMX)
Hello_GUI_CMI:=$(PLUGIN_GUI_CMI)

# Interface for the the packed plugins
TARGET_MLI:= $(PLUGIN_LIB_DIR)/Hello.mli
TARGET_CMI:= $(TARGET_MLI:.mli=.cmi)

# The packed files for toplevel mode (in directory 'top')
TARGET_TOP_MLI:= $(PLUGIN_LIB_DIR)/top/Hello.mli
TARGET_TOP_CMI:= $(TARGET_TOP_MLI:.mli=.cmi)
TARGET_TOP_CMO:= $(TARGET_TOP_MLI:.mli=.cmo)
ifdef PLUGIN_EXTRA_BYTE
TARGET_TOP_CMA:= $(TARGET_TOP_CMO:.cmo=.cma)
else
TARGET_TOP_CMA:=
endif

TARGET_TOP_CMX:= $(TARGET_TOP_CMO:.cmo=.cmx)

TARGET_TOP_CMXS:= $(TARGET_TOP_CMX:.cmx=.cmxs)

# The packed files for GUI mode (in directory 'gui')
ifeq ($(HAS_GUI),yes)
TARGET_GUI_MLI:=$(PLUGIN_LIB_DIR)/gui/Hello.mli
TARGET_GUI_CMO:= $(PLUGIN_LIB_DIR)/gui/Hello.cmo
TARGET_GUI_CMI:= $(TARGET_GUI_CMO:.cmo=.cmi)
TARGET_GUI_CMX:= $(TARGET_GUI_CMO:.cmo=.cmx)
TARGET_GUI_CMA:= $(TARGET_GUI_CMO:.cmo=.cma)
TARGET_GUI_CMXS:= $(TARGET_GUI_CMO:.cmo=.cmxs)
else
TARGET_GUI_MLI:=
TARGET_GUI_CMO:=
TARGET_GUI_CMI:=
TARGET_GUI_CMX:=
TARGET_GUI_CMA:=
endif

# Meta-variables for the targets:
Hello_TARGET_MLI:=$(TARGET_MLI)
Hello_TARGET_CMI:=$(TARGET_CMI)
Hello_TARGET_TOP_MLI:=$(TARGET_TOP_MLI)
Hello_TARGET_TOP_CMI:=$(TARGET_TOP_CMI)
Hello_TARGET_TOP_CMO:=$(TARGET_TOP_CMO)
Hello_TARGET_TOP_CMA:=$(TARGET_TOP_CMA)
Hello_TARGET_TOP_CMX:=$(TARGET_TOP_CMX)
Hello_TARGET_TOP_CMXS:=$(TARGET_TOP_CMXS)
Hello_TARGET_GUI_MLI:=$(TARGET_GUI_MLI)
Hello_TARGET_GUI_CMI:=$(TARGET_GUI_CMI)
Hello_TARGET_GUI_CMO:=$(TARGET_GUI_CMO)
Hello_TARGET_GUI_CMA:=$(TARGET_GUI_CMA)
Hello_TARGET_GUI_CMX:=$(TARGET_GUI_CMX)
Hello_TARGET_GUI_CMXS:=$(TARGET_GUI_CMXS)

# Some meta-variables for compilation flags
NAME_BFLAGS :=Hello_BFLAGS
NAME_OFLAGS :=Hello_OFLAGS
TARGET_OFLAGS :=Hello_TARGET_OFLAGS
TARGET_BFLAGS :=Hello_TARGET_BFLAGS
ifeq ($(HAS_GUI),yes)
NAME_GUI_BFLAGS :=Hello_GUI_BFLAGS
NAME_GUI_OFLAGS :=Hello_GUI_OFLAGS
TARGET_GUI_OFLAGS:=Hello_GUI_TARGET_OFLAGS
TARGET_GUI_BFLAGS:=Hello_GUI_TARGET_BFLAGS
endif
NAME_DEPFLAGS :=Hello_DEPFLAGS
NAME_DOCFLAGS :=Hello_DOCFLAGS

# Export some variables which can be safely used outside/inside Makefile.plugin
Hello_CMO:=$(PLUGIN_CMO)
Hello_CMX:=$(PLUGIN_CMX)
Hello_CMI:=$(PLUGIN_CMI)
Hello_GENERATED:=$(PLUGIN_GENERATED)
Hello_TARGET_BFLAGS:=$(PLUGIN_LINK_BFLAGS)
Hello_TARGET_OFLAGS:=$(PLUGIN_LINK_OFLAGS)
Hello_EXTRA_BYTE:=$(PLUGIN_EXTRA_BYTE)
Hello_EXTRA_OPT:=$(PLUGIN_EXTRA_OPT)
Hello_EXTRA_DIRS:=$(PLUGIN_EXTRA_DIRS)

ifeq ($(HAS_GUI),yes)
# gui variable
Hello_GUI_CMO:=$(PLUGIN_GUI_CMO)
Hello_GUI_CMX:=$(PLUGIN_GUI_CMX)
Hello_GUI_CMI:=$(PLUGIN_GUI_CMI)
Hello_GUI_CMI_ONLY:=$(PLUGIN_GUI_CMI_ONLY)
Hello_GUI_TARGET_BFLAGS:=$(PLUGIN_LINK_GUI_BFLAGS)
Hello_GUI_TARGET_OFLAGS:=$(PLUGIN_LINK_GUI_OFLAGS)
endif

PLUGIN_EXTRA_DIRS_INC:=$(patsubst %,-I $(PLUGIN_DIR)/% ,$(PLUGIN_EXTRA_DIRS))

# Set the compilation flags for the plugin
INCLUDE_FLAGS:=-I $(PLUGIN_DIR) -I $(INSTALLED_PLUGIN_DIR) \
			$(PLUGIN_EXTRA_DIRS_INC) \
			$(addprefix -package ,$(PLUGIN_REQUIRES) $(LIBRARY_NAMES))

$(NAME_BFLAGS):=$(BFLAGS) $(INCLUDE_FLAGS) $(PLUGIN_BFLAGS)
$(NAME_OFLAGS):=$(OFLAGS) $(INCLUDE_FLAGS) $(PLUGIN_OFLAGS)

$(TARGET_BFLAGS):= $(PLUGIN_LINK_BFLAGS)
$(TARGET_OFLAGS):= $(PLUGIN_LINK_OFLAGS)
$(NAME_DOCFLAGS):= $(DOC_FLAGS) $(PLUGIN_DOCFLAGS) \
			-I $(PLUGIN_DIR) \
			$(PLUGIN_EXTRA_DIRS_INC) \
			-I $(PLUGIN_LIB_DIR) \
			$(addprefix -package ,$(PLUGIN_REQUIRES) $(LIBRARY_NAMES))

ifeq ($(HAS_GUI),yes)
$(NAME_GUI_BFLAGS):=$($(NAME_BFLAGS)) $(addprefix -package ,$(LIBRARY_NAMES_GUI))
$(NAME_GUI_OFLAGS):=$($(NAME_OFLAGS)) $(addprefix -package ,$(LIBRARY_NAMES_GUI))
$(TARGET_GUI_BFLAGS):= $(PLUGIN_LINK_GUI_BFLAGS)
$(TARGET_GUI_OFLAGS):= $(PLUGIN_LINK_GUI_OFLAGS)
$(NAME_DOCFLAGS) := $($(NAME_DOCFLAGS)) $(addprefix -package ,$(LIBRARY_NAMES_GUI))
endif
$(NAME_DEPFLAGS):= -I $(PLUGIN_DIR) $(PLUGIN_DEPFLAGS) $(PLUGIN_EXTRA_DIRS_INC)

# Add the flags to the compilation line of the plugin source files
$(PLUGIN_CMO) $(PLUGIN_CMI) $(PLUGIN_INFERRED_MLI): BFLAGS:=$($(NAME_BFLAGS))
$(PLUGIN_CMX): OFLAGS:=$($(NAME_OFLAGS)) -for-pack Hello

ifeq ($(HAS_GUI),yes)
$(PLUGIN_GUI_CMO) $(PLUGIN_GUI_CMI): BFLAGS:=$($(NAME_GUI_BFLAGS))
$(PLUGIN_GUI_CMX): OFLAGS:=$($(NAME_GUI_OFLAGS)) -for-pack Hello
endif

# META file
PLUGIN_PKG  :=$(shell echo frama-c-Hello | tr '[:upper:]' '[:lower:]')
DEPEND_PKG  :=$(shell echo $(PLUGIN_DEPENDENCIES) | tr '[:upper:]' '[:lower:]')
PLUGIN_REQUIRES += $(addprefix frama-c-,$(DEPEND_PKG))
TARGET_META :=$(PLUGIN_LIB_DIR)/META.$(PLUGIN_PKG)

ifneq ($(PLUGIN_HAS_META),yes)
# generated META
ifeq ($(PLUGIN_DESCRIPTION),)
PLUGIN_DESCRIPTION :="Frama-C Hello plug-in"
endif
ifeq ($(PLUGIN_VERSION),)
ifeq ($(FRAMAC_INTERNAL),yes)
ifeq ($(FRAMAC_ROOT_SRCDIR),)
PLUGIN_VERSION :=$(shell cat VERSION)
else
# To remove "cat: VERSION: No such file or directory" in EXECNOW target performing make commands under a plugin directory
PLUGIN_VERSION :=$(shell cat $(FRAMAC_ROOT_SRCDIR)/VERSION)
endif
else
PLUGIN_VERSION :=$(shell frama-c-config -print-version)
endif
endif
# registering package description for later use
META.$(PLUGIN_PKG).DESCRIPTION :=$(PLUGIN_DESCRIPTION)
META.$(PLUGIN_PKG).VERSION     :=$(PLUGIN_VERSION)
META.$(PLUGIN_PKG).REQUIRES    :=$(PLUGIN_REQUIRES)
ifdef PLUGIN_EXTRA_BYTE
META.$(PLUGIN_PKG).BYTE :=Hello.cma
else
META.$(PLUGIN_PKG).BYTE :=Hello.cmo
endif
META.$(PLUGIN_PKG).NATIVE :=Hello.cmx
META.$(PLUGIN_PKG).PLUGIN :=Hello.cmxs

ifeq ($(FRAMAC_INTERNAL),yes)
# In internal mode, we depend on the main Makefile for plugins that do not
# have their own Makefile. To detect that, we check whether there is a
# plugin-specific Makefile in the include stack.
ifeq ($(filter $(PLUGIN_DIR)/Makefile,$(MAKEFILE_LIST)),)
$(TARGET_META): Makefile
else
$(TARGET_META): $(PLUGIN_DIR)/Makefile
endif # PLUGIN_DIR/Makefile
else
$(TARGET_META): $(PLUGIN_DIR)/Makefile
endif # FRAMAC_INTERNAL

$(TARGET_META):
	$(PRINT_MAKING) $(notdir $@)
	$(RM) $@
	$(ECHO) "description = \"$($(notdir $@).DESCRIPTION)\"" >> $@
	$(ECHO) "version = \"$($(notdir $@).VERSION)\""         >> $@
	$(ECHO) "requires = \"$($(notdir $@).REQUIRES)\""       >> $@
	$(ECHO) "archive(byte) = \"top/$($(notdir $@).BYTE)\""      >> $@
	$(ECHO) "archive(native) = \"top/$($(notdir $@).NATIVE)\""  >> $@
	$(ECHO) "plugin(native) = \"top/$($(notdir $@).PLUGIN)\""  >> $@
	$(ECHO) "plugin(byte) = \"top/$($(notdir $@).BYTE)\""  >> $@
ifeq ($(HAS_GUI),yes)
	$(ECHO) "archive(byte,gui) = \"gui/$($(notdir $@).BYTE)\""      >> $@
	$(ECHO) "archive(native,gui) = \"gui/$($(notdir $@).NATIVE)\""  >> $@
	$(ECHO) "plugin(native,gui) = \"gui/$($(notdir $@).PLUGIN)\""  >> $@
	$(ECHO) "plugin(byte,gui) = \"gui/$($(notdir $@).BYTE)\""  >> $@
endif
	$(ECHO) "directory = \"\"" >> $@

else # PLUGIN_HAS_META
# user-defined META
$(TARGET_META): $(PLUGIN_DIR)/META
	$(PRINT_CP) $(notdir $@)
	$(CP) $< $@
	$(ECHO) "directory = \"\"" >> $@
endif # PLUGIN_HAS_META

# Now build the targets
#######################

Hello_PLUGIN_MLI:= $(PLUGIN_DIR)/Hello.mli
Hello_CHECK_PLUGIN_MLI:=$(PLUGIN_DIR)/Hello.check_mli_exists

# Prevents warning 58 in OCaml 4.03 for our plugins.
ifeq ($(HAS_OCAML403),yes)
  $(TARGET_CMI): BFLAGS:=$($(NAME_BFLAGS)) -opaque
else
  $(TARGET_CMI): BFLAGS:=$($(NAME_BFLAGS))
endif

$(TARGET_CMI): $(PLUGIN_CMO)


ifneq ($(TARGET_MLI),$(Hello_PLUGIN_MLI))
# Copy the plugin interface in the plugins directory
$(TARGET_MLI): $(Hello_CHECK_PLUGIN_MLI)
	$(PRINT_MAKING) $@
	$(MKDIR) $(PLUGIN_LIB_DIR)
	$(RM) $@
	$(ECHO) "(* This module was generated automatically by code in Makefile and $(Hello_PLUGIN_MLI) *)" > $@
	$(ECHO) "#1 \"$(Hello_PLUGIN_MLI)\"" >> $@
	$(CAT) $(Hello_PLUGIN_MLI) >> $@
	$(CHMOD_RO) $@

$(INSTALLED_PLUGIN_DIR)/.placeholders_ready: $(TARGET_MLI)

PLUGIN_GENERATED+= $(TARGET_MLI)
endif

$(TARGET_TOP_MLI): $(Hello_CHECK_PLUGIN_MLI) $(TARGET_MLI)
	$(PRINT_MAKING) $@
	$(MKDIR) $(PLUGIN_LIB_DIR)/top
	$(RM) $@
	$(CP) $(Hello_TARGET_MLI) $@

PLUGIN_GENERATED+= $(TARGET_TOP_MLI)

Hello_MLI:=$(TARGET_MLI)

$(TARGET_TOP_CMI): $(TARGET_CMI)
	$(PRINT_MAKING) $@
	$(MKDIR) $(PLUGIN_LIB_DIR)/top
	$(RM) $@
	$(CP) $< $@


$(TARGET_TOP_CMO): $(PLUGIN_CMO) \
		   $(TARGET_CMI) $(TARGET_TOP_CMI)
	$(PRINT_PACKING) $@
	$(OCAMLC) -o $(call winpath,$@) $(Hello_BFLAGS) -pack \
	  $(Hello_TARGET_BFLAGS) \
	  $(Hello_CMI_ONLY) $(Hello_CMO)

$(TARGET_TOP_CMX): $(PLUGIN_CMX) \
		   $(TARGET_CMI) $(TARGET_TOP_CMI)
	$(PRINT_PACKING) $@
	$(OCAMLOPT) -o $(call winpath,$@) $(Hello_OFLAGS) -pack \
	  $(Hello_TARGET_OFLAGS) \
	  $(Hello_CMI_ONLY) $(Hello_CMX)

$(TARGET_TOP_CMXS): $(TARGET_TOP_CMX) $(PLUGIN_EXTRA_OPT)
	$(PRINT_PACKING) $@
	$(OCAMLOPT) -o $(call winpath,$@) -shared \
	  $(Hello_OFLAGS) \
	  $(Hello_EXTRA_OPT) \
          $(@:.cmxs=.cmx)

ifdef PLUGIN_EXTRA_BYTE
$(TARGET_TOP_CMA): $(PLUGIN_EXTRA_BYTE) $(TARGET_TOP_CMO)
	$(PRINT_PACKING) $@
	$(OCAMLC) -o $(call winpath,$@) $(Hello_BFLAGS) \
	  $(Hello_TARGET_BFLAGS) \
	  -a $(Hello_EXTRA_BYTE) $(@:.cma=.cmo)
endif

ifeq ($(HAS_GUI),yes)
# packing gui files
###################

$(TARGET_GUI_CMI): $(TARGET_CMI)
	$(PRINT_MAKING) $@
	$(MKDIR) $(PLUGIN_LIB_DIR)/gui
	$(RM) $@
	$(CP) $< $@

PLUGIN_GENERATED+= $(TARGET_GUI_MLI)

$(TARGET_GUI_MLI): $(Hello_CHECK_PLUGIN_MLI) $(TARGET_MLI)
	$(PRINT_MAKING) $@
	$(MKDIR) $(PLUGIN_LIB_DIR)/gui
	$(RM) $@
	$(CP) $(Hello_TARGET_MLI) $@

$(TARGET_GUI_CMO): $(PLUGIN_GUI_CMO) $(TARGET_CMI) $(TARGET_GUI_CMI)
	$(PRINT_PACKING) $@
	$(MKDIR) $(PLUGIN_LIB_DIR)/gui
	$(OCAMLC) -o $(call winpath,$@) $(Hello_GUI_BFLAGS) -pack \
	  $(Hello_GUI_TARGET_BFLAGS) \
	  $(Hello_GUI_CMI_ONLY) \
	  $(Hello_GUI_CMO)

$(TARGET_GUI_CMX): $(PLUGIN_GUI_CMX) $(TARGET_CMI) $(TARGET_GUI_CMI)
	$(PRINT_PACKING) $@
	$(MKDIR) $(PLUGIN_LIB_DIR)/gui
	$(OCAMLOPT) -o $(call winpath,$@) $(Hello_GUI_OFLAGS) -pack \
	  $(Hello_GUI_TARGET_OFLAGS) \
	  $(Hello_GUI_CMI_ONLY) \
	  $(Hello_GUI_CMX)

$(TARGET_GUI_CMXS): $(TARGET_GUI_CMX)
	$(PRINT_PACKING) $@
	$(MKDIR) $(PLUGIN_LIB_DIR)/gui
	$(OCAMLOPT) -o $(call winpath,$@) -shared \
	  $(Hello_GUI_OFLAGS) \
          $(Hello_GUI_TARGET_OFLAGS) \
          $(Hello_EXTRA_OPT) \
	  $^

ifdef PLUGIN_EXTRA_BYTE
$(TARGET_GUI_CMA): $(PLUGIN_EXTRA_BYTE) $(TARGET_GUI_CMO)
	$(PRINT_PACKING) $@
	$(OCAMLC) -o $(call winpath,$@) $(Hello_GUI_BFLAGS) \
	  $(Hello_GUI_TARGET_BFLAGS) \
	  -a $(Hello_EXTRA_BYTE) $(@:.cma=.cmo)
endif

else
# No specific gui items
TARGET_GUI_MLI:=
TARGET_GUI_CMI:=
endif # HAS_GUI

#########

# The following rules used some plugin info (name and path) in their names
# in order to used them in the command:
# it is not possible to use $(PLUGIN_*) in commands due to the evaluation rules
# of make

##########################
# Internal documentation #
##########################

MODULES_TODOC+= $(PLUGIN_TYPES_TODOC)

PLUGIN_UNDOC := $(addprefix $(PLUGIN_DIR)/,$(PLUGIN_UNDOC))

PLUGIN_DOC_SRC:=$(filter-out $(PLUGIN_UNDOC),$(PLUGIN_ML_SRC))
Hello_DOC_SRC:=$(PLUGIN_DOC_SRC)

ifndef PLUGIN_DOC_DIR
PLUGIN_DOC_DIR := $(DOC_DIR)/$(PLUGIN_BASE)
endif

Hello_DOC_DIR:= $(PLUGIN_DOC_DIR)

Hello_INTRO:=$(PLUGIN_INTRO)
ifdef PLUGIN_INTRO
Hello_CAT_INTRO:= cp -f $(PLUGIN_INTRO) $(PLUGIN_DOC_DIR)/Hello.txt
ifeq ($(PLUGIN_DISTRIBUTED),yes)
PLUGIN_DIST_EXTERNAL_LIST+= $(PLUGIN_INTRO)
endif
else
Hello_CAT_INTRO:= echo "" > $(PLUGIN_DOC_DIR)/Hello.txt
endif

ifeq ($(FRAMAC_INTERNAL),yes)
DOC_INTRO:= $(DOC_DIR)/intro_kernel_plugin.txt \
            $(DOC_DIR)/intro_plugin.txt \
	    $(DOC_DIR)/intro_plugin_D_and_S.txt \
	    $(DOC_DIR)/intro_plugin_default.txt
else
DOC_INTRO:=
endif

$(Hello_DOC_DIR)/Hello.txt: $(DOC_INTRO) $(Hello_INTRO)
	$(PRINT_MAKING) "$@"
	$(MKDIR) $(dir $@)
	$(Hello_CAT_INTRO)
	if [ -f "$(DOC_DIR)/html/Db.Hello.html" ] ; then \
	  if [ -f "$(DOC_DIR)/dynamic_plugins/Dynamic_plugins.Hello.html" ] ; then \
	    cat $(DOC_DIR)/intro_plugin_D_and_S.txt >> $@ ; \
	  else \
	    cat $(DOC_DIR)/intro_kernel_plugin.txt >> $@ ; \
	  fi ; \
	elif [ -f "$(DOC_DIR)/dynamic_plugins/Dynamic_plugins.Hello.html" ] ; then \
	  cat $(DOC_DIR)/intro_plugin.txt >> $@ ; \
	else \
	  cat $(DOC_DIR)/intro_plugin_default.txt >> $@ ; \
	fi
	$(ISED) -e "s/_PluginName_/Hello/g" \
                -e "/^#\*/d" $@

ifeq ($(FRAMAC_INTERNAL),yes)
OCAMLDOC_GEN:=$(DOC_PLUGIN)
OCAMLDOC_GEN+=$(DOC_DIR)/kernel-doc.ocamldoc

else
OCAMLDOC_GEN:=

# not doing kernel documentation if just compiling plugin's one

$(DOC_DIR)/docgen.cmo: $(DOC_DIR)/docgen.ml
	$(PRINT_OCAMLC) $@
	$(OCAMLC) -c -I +ocamldoc $(call winpath,$(DOC_DIR))/docgen.ml

$(DOC_DIR)/docgen.cmxs: $(DOC_DIR)/docgen.ml
	$(PRINT_PACKING) $@
	$(OCAMLOPT) -o $(call winpath,$@) -shared -I +ocamldoc \
	  $(call winpath,$(DOC_DIR))/docgen.ml
endif

OCAMLDOC_DEPEND:= $(PLUGIN_CMO)
ifneq ($(ENABLE_GUI),no)
OCAMLDOC_DEPEND:= $(OCAMLDOC_DEPEND) $(PLUGIN_GUI_CMO)
endif

.PHONY: Hello_DOC
Hello_DOC: $(OCAMLDOC_DEPEND) \
		    $(OCAMLDOC_GEN) \
		    $(Hello_DOC_DIR)/Hello.txt \
		    $(Hello_DOC_DIR)/modules.svg \
		    $(DOC_PLUGIN)
	$(PRINT_DOC) Hello
	$(MKDIR) $(Hello_DOC_DIR)
	$(RM) $(Hello_DOC_DIR)/*.html
# Only generate toc for kernel's documentation if we are in Frama-C's main
# Makefile
ifeq ($(FRAMAC_INTERNAL),yes)
	$(ECHO) '<li><a href="$(subst $(DOC_DIR)/,,$(Hello_DOC_DIR))/index.html">$(subst _, ,Hello)</a></li>' > $(DOC_DIR)/Hello.toc
endif
	$(OCAMLDOC) $(Hello_DOCFLAGS) \
	  -t "Hello plugin" \
	  -css-style ../style.css \
	  -d $(Hello_DOC_DIR) -g $(DOC_PLUGIN) -passopt -docpath $(DOC_DIR)/html \
	  $(addprefix -load ,$(wildcard $(DOC_DIR)/kernel-doc.ocamldoc)) \
	  $(wildcard $(Hello_DOC_SRC))
# [rb+js] 20090619
# pwd is required to avoid "bad directory" message on OpenBSD
# don't know why
	cd `pwd`/$(Hello_DOC_DIR); \
	for f in $(foreach f,$(Hello_TYPES_TODOC),\
	                     $(basename $(notdir $f))); do \
	  for g in \
	    $(wildcard ../html/$(shell $(ECHO) $(f) | $(SED) 's/^./\u&/')); \
          do \
	    ln -sf $$g; \
	  done; \
	done; \
        for f in *.html; do \
	  $(ISED) -e 's|\(doc/code/html\)|../../../\1|g' $$f ; \
	done


# removed dependencies:
#		    $(PLUGIN_DOC_DIR)/modules.ps \
#		    $(PLUGIN_DOC_DIR)/modules-all.ps \
#		    $(PLUGIN_DOC_DIR)/types.ps
$(PLUGIN_DOC_DIR)/modules.dot: DOC_FLAGS:=$($(NAME_DOCFLAGS))
$(PLUGIN_DOC_DIR)/modules.dot: $(wildcard $(PLUGIN_DOC_SRC))
	$(PRINT_DOC) $@
	$(MKDIR) $(dir $@)
	$(OCAMLDOC) $(DOC_FLAGS) -o $@ -dot $^ \
        || { $(RM) $@; exit 2; } # in case of error, ocamldoc still generates
	                         # something
	$(ISED) -e "s/rotate=90;//" \
		-e 's/digraph G/digraph "Plugin architecture ($(subst /,,$(subst doc/code,,$(dir $@))))"/' \
		$@

$(PLUGIN_DOC_DIR)/modules-all.dot: DOC_FLAGS:=$($(NAME_DOCFLAGS))
$(PLUGIN_DOC_DIR)/modules-all.dot: $(wildcard $(PLUGIN_DOC_SRC))
	$(PRINT_DOC) $@
	$(MKDIR) $(dir $@)
	$(OCAMLDOC) $(DOC_FLAGS) $($(dir $@)FLAGS) -o $@ -dot \
	  -dot-include-all $^
	$(ISED) -e "s/rotate=90;//" $@

$(PLUGIN_DOC_DIR)/types.dot: DOC_FLAGS:=$($(NAME_DOCFLAGS))
$(PLUGIN_DOC_DIR)/types.dot: $(wildcard $(PLUGIN_DOC_SRC))
	$(PRINT_DOC) $@
	$(MKDIR) $(dir $@)
	$(OCAMLDOC) $(DOC_FLAGS) $($(dir $@)FLAGS) -o $@ -dot -dot-types $^
	$(ISED) -e "s/rotate=90;//" $@

.PHONY: Hello_metrics
Hello_metrics : $(PLUGIN_DOC_DIR)/metrics.html
$(PLUGIN_DOC_DIR)/metrics.html : $(wildcard $(PLUGIN_DOC_SRC))
	$(PRINT_DOC) $@
	ocamlmetrics $^ > $@

############
# Tests    #
############

ifneq ("$(PLUGIN_ENABLE)","no")
ifndef PLUGIN_NO_TEST
ifndef PLUGIN_TESTS_DIRS
PLUGIN_TESTS_DIRS:=$(PLUGIN_BASE)
endif
endif

ifndef PLUGIN_TESTS_DIRS_DEFAULT
PLUGIN_TESTS_DIRS_DEFAULT:=$(PLUGIN_TESTS_DIRS)
endif

ifndef PLUGIN_NO_DEFAULT_TEST
ifdef PLUGIN_INTERNAL_TEST
PLUGIN_TESTS_LIST += $(PLUGIN_TESTS_DIRS_DEFAULT)
endif
endif

Hello_TESTS_DIRS:=$(PLUGIN_TESTS_DIRS)

Hello_TESTS_LIB_DIR:=$(sort $(dir $(PLUGIN_TESTS_LIB)))
Hello_TESTS_LIB_DIR_INCLUDE:=$(foreach d,$(Hello_TESTS_LIB_DIR),-I $d )
Hello_EXTRA_DIRS:=$(Hello_EXTRA_DIRS) $(Hello_TESTS_LIB_DIR)
Hello_TESTS_LIB_OPT:=$(PLUGIN_TESTS_LIB:%.ml=%.cmx)
Hello_TESTS_LIB_OPT_DYN:=$(PLUGIN_TESTS_LIB:%.ml=%.cmxs)
Hello_TESTS_LIB_BYTE:=$(PLUGIN_TESTS_LIB:%.ml=%.cmo)

$(Hello_TESTS_LIB_OPT): OFLAGS:=$($(NAME_OFLAGS)) $(Hello_TESTS_LIB_DIR_INCLUDE)
$(Hello_TESTS_LIB_OPT_DYN): OFLAGS:=$($(NAME_OFLAGS)) $(Hello_TESTS_LIB_DIR_INCLUDE)
$(Hello_TESTS_LIB_BYTE): BFLAGS:=$($(NAME_BFLAGS)) $(Hello_TESTS_LIB_DIR_INCLUDE)

# [JS 2009/03/18] both .PRECIOUS are required in order to prevent 'make'
# deletion of intermediate generated files. Such a deletion forces 'make' to
# unnecessarily recompile those files.
.PRECIOUS: $(Hello_TESTS_LIB_OPT) \
           $(Hello_TESTS_LIB_OPT_DYN) \
           $(Hello_TESTS_LIB_BYTE) \
           $(Hello_TESTS_LIB_BYTE:%.cmo=%.cmi)
endif # PLUGIN_ENABLE

##########
# Depend #
##########

# for reasons known to themselves, ocamldep and make are confused by ./file.ml
# hence (one of) the patsubst below in case PLUGIN_DIR is .

# If you explicitly do "make depend" it is
# $(PLUGIN_DIR)/Hello_DEP_REDO. it forces the computation of
# dependencies. Otherwise usual dependency for $(PLUGIN_DIR)/.depend.
.PHONY: $(Hello_DIR)/Hello_DEP_REDO
$(Hello_DIR)/Hello_DEP_REDO $(Hello_DIR)/.depend: \
	$(PLUGIN_GENERATED)
	$(PRINT_DEP) $(Hello_DIR)/.depend
	$(RM) $(Hello_DIR)/.depend
	$(OCAMLDEP) $(INCLUDES) \
	  $(Hello_DEPFLAGS) \
	  $(patsubst ./%,%,\
	    $(Hello_ML_SRC) \
	    $(Hello_MLI) \
	    $(Hello_GUI_MLI)) \
	  $(foreach d,$(Hello_TESTS_LIB_DIR),\
	    -I $d $d*.ml $d*.mli) \
	  > $(Hello_DIR)/.depend
	$(CHMOD_RO) $(Hello_DIR)/.depend

depend:: $(Hello_DIR)/Hello_DEP_REDO

#Just for backward compatibility (19/10/2015)
$(Hello_DIR)/Hello_DEP: $(Hello_DIR)/.depend
	$(TOUCH) $@

#In internal mode wait for lib/plugins to be populated by .mli.
ifeq ($(FRAMAC_INTERNAL),yes)
$(Hello_DIR)/Hello_DEP_REDO $(Hello_DIR)/.depend: $(INSTALLED_PLUGIN_DIR)/.placeholders_ready
endif

# MAKECMDGOALS contains the targets passed to make. We set it to non-empty
# (if needed) to silence warnings about undefined variables.
MAKECMDGOALS ?=

ifneq ($(MAKECMDGOALS),clean)
ifneq ($(MAKECMDGOALS),distclean)
ifneq ($(MAKECMDGOALS),smartclean)
sinclude $(PLUGIN_DIR)/.depend
endif
endif
endif

############
# Cleaning #
############

.PHONY: $(PLUGIN_DIR)/Hello_CLEAN
$(PLUGIN_DIR)/Hello_CLEAN:
	$(PRINT_RM) $(patsubst %_CLEAN,%,$(notdir $@))
	if test "$(FRAMAC_INTERNAL)" = "yes"; then \
          $(RM) $(dir $@).depend; \
        fi
	$(RM) $(PLUGIN_GENERATED)
	$(RM) $(@:%CLEAN=%DEP) $(@:%CLEAN=%DEP_REDO)
	$(RM) $(patsubst %.cmo,%.cm*,$($(patsubst %_CLEAN,%_CMO,$(notdir $@))))
	$(RM) $(patsubst %.cmi,%.cm*,$($(patsubst %_CLEAN,%_CMI,$(notdir $@))))
	$(RM) $(patsubst %.cmo,%.annot,\
                         $($(patsubst %_CLEAN,%_CMO,$(notdir $@))))
	$(RM) $(patsubst %.cmo,%.o,$($(patsubst %_CLEAN,%_CMO,$(notdir $@))))
	$(RM) $(patsubst %.cmo,%.cm*,\
                 $($(patsubst %_CLEAN,%_GUI_CMO,$(notdir $@))))
	$(RM) $(patsubst %.cmi,%.cm*,\
                 $($(patsubst %_CLEAN,%_GUI_CMI,$(notdir $@))))
	$(RM) $(patsubst %.cmo,%.annot,\
                 $($(patsubst %_CLEAN,%_GUI_CMO,$(notdir $@))))
	$(RM) $(patsubst %.cmo,%.o,\
                 $($(patsubst %_CLEAN,%_GUI_CMO,$(notdir $@))))
	$(RM) $(dir $@)*~ $(dir $@)*.cm* $(dir $@)*.o $(dir $@)*.annot
	$(RM) $(foreach d,$(@:%CLEAN=%TESTS_LIB_OPT),\
		$(foreach f,$($(notdir $d)),\
		$f $(f:.cmx=.cm*) $(f:.cmx=.opt) $(f:.cmx=.byte) $(f:.cmx=.o)))
	$(RM) -f $(Hello_CHECK_PLUGIN_MLI)


.PHONY: $(PLUGIN_DIR)/Hello_DIST_CLEAN
$(PLUGIN_DIR)/Hello_DIST_CLEAN:
	$(RM) $(dir $@)/tests/ptests_config

.PHONY: $(PLUGIN_DIR)/Hello_CLEAN_DOC $(Hello_DOC_DIR)
$(PLUGIN_DIR)/Hello_CLEAN_DOC: $(Hello_DOC_DIR)
	$(PRINT_RM) documentation of  $(patsubst %_CLEAN_DOC,%,$(notdir $@))
	$(RM) -r $<
	$(RM) $(DOC_DIR)/$(notdir $(patsubst %_CLEAN_DOC,%,$@).toc)

# Global lists seen in Makefile

PLUGIN_GENERATED_LIST += $(PLUGIN_GENERATED)

PLUGIN_META_LIST += $(TARGET_META)
PLUGIN_DYN_CMI_LIST += $(TARGET_CMI)
ifdef PLUGIN_EXTRA_BYTE
.PRECIOUS: $(TARGET_TOP_CMO)
PLUGIN_DYN_CMO_LIST += $(TARGET_TOP_CMA)
else
PLUGIN_DYN_CMO_LIST += $(TARGET_TOP_CMO)
endif
PLUGIN_DYN_DEP_GUI_CMO_LIST += $(PLUGIN_GUI_CMO)
ifeq ($(HAS_GUI),yes)
PLUGIN_DYN_GUI_EXISTS:=yes
ifdef PLUGIN_EXTRA_BYTE
PLUGIN_DYN_GUI_CMO_LIST += $(TARGET_GUI_CMA)
else
PLUGIN_DYN_GUI_CMO_LIST += $(TARGET_GUI_CMO)
endif #EXTRA_BYTE
endif #HAS_GUI

PLUGIN_DYN_DEP_GUI_CMX_LIST += $(PLUGIN_GUI_CMX)
PLUGIN_DYN_CMX_LIST	+= $(TARGET_TOP_CMXS) $(TARGET_TOP_CMX)
      # If P1 depends on P2, then dynamically link P1.cmxs requires to have 
      # compiled P1's sources wrt the P2's .cmx.
ifeq ($(HAS_GUI),yes)
PLUGIN_DYN_GUI_CMX_LIST += $(TARGET_GUI_CMXS)
endif # HAS_GUI

PLUGIN_INTERNAL_CMO_LIST += $(PLUGIN_CMO)
PLUGIN_INTERNAL_CMX_LIST += $(PLUGIN_CMX)
PLUGIN_DOC_LIST += Hello_DOC
PLUGIN_DOC_DIRS += $(PLUGIN_BASE)

ifeq ($(PLUGIN_DISTRIBUTED),yes)
PLUGIN_DISTRIBUTED_NAME_LIST += Hello
PLUGIN_DISTRIBUTED_DIR_LIST += Hello
endif

else
$(PLUGIN_DIR)/Hello_DEP_REDO:
$(PLUGIN_DIR)/Hello_DEP:
$(PLUGIN_DIR)/Hello_CLEAN:
endif

# Reset each "local" plugin variable

ifneq ($(PLUGIN_RESET),no)
PLUGIN_RESET:=
PLUGIN_NAME:=
PLUGIN_DIR:=
PLUGIN_DESCRIPTION:=
PLUGIN_VERSION:=
PLUGIN_REQUIRES:=
PLUGIN_HAS_META:=
PLUGIN_CMI:=
PLUGIN_CMO:=
PLUGIN_BFLAGS:=
PLUGIN_OFLAGS:=
PLUGIN_DEPFLAGS:=
PLUGIN_DOCFLAGS:=
PLUGIN_GENERATED:=
PLUGIN_TYPES_CMO:=
PLUGIN_GUI_CMO:=
PLUGIN_GUI_CMX:=
PLUGIN_GUI_CMI:=
PLUGIN_GUI_MLI:=
PLUGIN_UNDOC:=
PLUGIN_TYPES_TODOC:=
PLUGIN_INTRO:=
PLUGIN_ENABLE:=
PLUGIN_NO_TEST:=
PLUGIN_TESTS_LIB:=
PLUGIN_TESTS_DIRS:=
PLUGIN_DEPENDS:=
PLUGIN_DEPENDENCIES:=
PLUGIN_DISTRIBUTED:=
PLUGIN_DISTRIB_EXTERNAL:=
PLUGIN_DISTRIB_TESTS:=
PLUGIN_HAS_EXT_DOC:=
PLUGIN_NO_DEFAULT_TEST:=
PLUGIN_TESTS_DIRS_DEFAULT:=
PLUGIN_LINK_GUI_BFLAGS:=
PLUGIN_LINK_GUI_OFLAGS:=
PLUGIN_LINK_BFLAGS:=
PLUGIN_LINK_OFLAGS:=
PLUGIN_EXTRA_BYTE:=
PLUGIN_EXTRA_OPT:=
PLUGIN_EXTRA_DIRS:=
PLUGIN_INTERNAL_TEST:=
PLUGIN_DOC_DIR:=
PLUGIN_HEADER_SPEC:=$(DEFAULT_HEADER_SPEC)
PLUGIN_HEADER_DIRS:=$(DEFAULT_HEADER_DIRS)
PLUGIN_HEADER_EXCEPTIONS:=$(DEFAULT_HEADER_EXCEPTIONS)
PLUGIN_CEA_PROPRIETARY_FILES:=$(DEFAULT_CEA_PROPRIETARY_FILES)
PLUGIN_CEA_PROPRIETARY_HEADERS:=
endif

###############################################################################
# Local Variables:
# mode: makefile
# End:
